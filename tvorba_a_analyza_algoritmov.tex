\chapter[Tvorba a analýza algoritmov]{Tvorba a analýza algoritmov}
\label{tvorba_a_analyza_algoritmov} % id kapitoly pre prikaz ref

%zdroje:
%https://www.ksp.sk/kucharka/
%http://www.dcs.fmph.uniba.sk/~anderle/tea/tea_skripta.pdf


\section{Analýza časovej zložitosti algoritmov} 

\subsection{Definícia časovej zložitosti} TODO
\subsection{O-notácia} TODO
\subsection{Odhad časovej zložitosti rekurzívnych algoritmov používajúcich metódu rozdeľuj a panuj} TODO

\section{Algoritmy pre triedenie}

	\subsection{Efektívne algoritmy triedenia porovnávaním} TODO
	\subsection{Triedenie v lineárnom čase} TODO
	\subsection{Dolný odhad časovej zložitosti každého triedenia porovnávaním} TODO

\section{Dátové štruktúry v poli}
	\subsection{Pole s dynamickou veľkosťou – vektor} TODO
	\subsection{Zásobník} TODO
	\subsection{Fronta} TODO
	\subsection{Binárna halda a implementácia prioritnej fronty pomocou nej} TODO

\section{Usporiadané dátové štruktúry}
	\subsection{Binárne vyhľadávacie stromy} TODO
	\subsection{Usporiadaná množina} TODO
	\subsection{Usporiadané asociatívne pole – slovník} TODO
	\subsection{Vyvažovanie binárnych stromov} TODO

\section{Hešovanie}

	\subsection{Kolízie a rôzne spôsoby ich riešenia} TODO
	\subsection{Narodeninový paradox} TODO
	\subsection{Množina} TODO
	\subsection{Asociatívne pole} TODO

\section{Základné grafové algoritmy}

	\subsection{Reprezentácie grafu v pamäti}

		\paragraph{Matica susednosti} - dvojrozmerné pole $n \times n$, v ktorom môžeme reprezentovať graf pomocou boolov pre neohodnotený, integerov pre ohodnotený graf. \\
		Výhody:
		\begin{itemize}
			\item Vieme priamo zistiť, či x susedí s y
			\item Prehľadná a jednoduchá na prácu
			\item Priama reprezentácia ohodnotených hrán
		\end{itemize}
		Nevýhody:
		\begin{itemize}
			\item Pri riedkych grafoch zaberá zbytočne veľa miesta
			\item Pomalé hľadanie susedov vrcholu (potrebujeme prejsť všetkých n pozícií)
			\item Nejde priamočiaro reprezentovať multigrafy (pre každé políčko si ale môžme pamätať zoznam hrán)
		\end{itemize}

		\paragraph{Zoznam susedov} - pre každý vrchol si pamätáme zoznam jeho susedov, napr v poli dĺžky n spájaných zoznamov alebo vo vektore vektorov. Vrcholy môžeme označovať integermi.
		\begin{itemize}
			\item Rýchly prístup ku všetkým hranám idúcim z vrcholu
			\item Zaberá menej miesta ako matica susedov pri riedkých grafoch
			\item Priamočiara reprezentácia multigrafu
		\end{itemize}
		Nevýhody:
		\begin{itemize}
			\item K hranám vieme pristupovať len sekvenčne
			\item V ohodnotených grafoch si musíme pamätať páry čísel
		\end{itemize}


		\paragraph{Objektová reprezentácia}
		V objekte reprezentujúcom vrchol si pamätáme referencie na jeho susedov. V princípe rovnaké ako zoznam susedov, ale s čitateľnejším kódom.

	\subsection{Prehľadávanie do hĺbky a do šírky}
		\paragraph{DFS}
			Rekurzívne prehľadáva graf, pamätáme si už navštívené vrcholy.
			Využitie: 
			\begin{itemize}
				\item Hľadanie mostov v grafoch.
				\item Hľadanie artikulácií v grafoch.
				\item Hľadanie silno súvislých komponentov v orientovaných grafoch
				\item Testovanie planarity grafov.
			\end{itemize}


		\paragraph{BFS}



Ak sú dva vrcholy v jednom komponente súvislosti, mohli by sme chcieť vypísať aj cestu, ktorá ich spája
Najlepšie najkratšiu cestu, teda takú, ktorá obsahuje najmenej hrán
To nám prehľadávanie do hĺbky nenájde, použijeme prehľadávanie do šírky
Začneme v nejakom vrchole s
V prehľadávaní do šírky najprv navštívime všetky vrcholy vo vzdialenosti 1 od s, potom vo vzdialenosti 2, ...
Pre každý navštívený vrchol v spočítame jeho vzdialenosť od s aj predposledný vrchol na najkratšej ceste z s do v
Hrany medzi v a pred[v] tvoria strom (kostru grafu, ak je súvislý)
Ak chceme vypísať cestu, po strome sa pohybujeme smerom k jeho koreňu vo vrchole s
Algoritmus používa rad (frontu, queue), do ktorej dáva vrcholy, ktoré už majú známu vzdialenosť, ale ešte sme nepozreli ich susedov
V rade sú v každej chvíli vrcholy najviac dvoch vzdialeností od s: najprv nejaké vrcholy vo vzdialenosti d, potom nejaké vrcholy vo vzdialenosti d+1
Zložitosť je tiež O(n+m), ak použijeme zoznamy susedov




	\subsection{Topologické triedenie} TODO
Motivačná úloha:

Na úrade potrebujeme vybaviť niekoľko potvrdení. Ale číha tam na nás byrokracia: o niektorých dvojiciach potvrdení vieme, že na získanie potvrdenia B potrebujeme predložiť potvrdenie A.
Úlohou je nájsť poradie (a zistiť, či také vôbec existuje) ako potvrdenia na úrade vybavovať.
Úlohu reprezentujeme ako orientovaný graf, kde vrcholy sú potvrdenia a hrany závislosti medzi nimi.
Topologické usporiadanie orientovaného grafu je permutácia jeho vrcholov $v_{1},v_{2},\dots v_{n}$ taká, že pre každú hranu $(v_{i},v_{j})$ platí, že $i<j$

t.j. všetky hrany idú v permutácii zľava doprava
orientovaný graf môže mať aj viac ako jedno topologické usporiadanie
Koľko najviac topologických usporiadaní môže mať orientovaný graf s n vrcholmi? Pre aký graf sa to stane?
Môže sa však stať, že graf nemá žiadne topologické usporiadanie
To sa stane práve vtedy, ak je v grafe orientovaný cyklus
Zjavne ak je v grafe orientovaný cyklus, topologické usporiadanie neexistuje, lebo v topologickom usporiadaní idú hrany zľava doprava a cyklus sa nemá ako vrátiť späť
Skúste si dokázať aj opačnú implikáciu
Graf bez cyklu voláme acyklický

Samotné topologické triedenie bude pracovať nasledovne:

ak máme vrchol, do ktorého nevchádza žiadna hrana, môžeme ho vypísať (potvrdenie, ktoré nemá žiadne závislosti)
z tohto vrcholu vychádzajú hrany, môžeme ich odteraz ignorovať (splnené závislosti)
pre každý vrchol si pamätáme počet zatiaľ nesplnených závislostí
na začiatku to bude počet hrán vchádzajúcich do vrchola
keď vypíšeme vrchol v, prejdeme všetky hrany z neho vychádzajúce a vrcholom na druhom konci znížime počet nesplnených závislostí
udržujeme si tiež množinu vrcholov, ktoré už nemajú nesplnené závislosti a v každom kroku jeden vrchol z nej vyberieme a vypíšeme

\section{Najkratšie cesty v grafe}
	Vedia pracovať len na ohodnotených grafoch s nezápornými cenami hrán. Neexistujúce cesty medzi 
	\subsection{Dijkstrov algoritmus} TODO
		Vypočíta najlacnejšiu cestu v grafe začínajúcu v konkrétnom vrchole $v_{0}$. Výstupom je pole cien ciest z $v_{0}$ do každého $v \in G$.
		Worst-case: $O(|V|^{2})$
	\subsection{Floydov-Warshallov algoritmus} TODO
		Vypočíta najlacnejšiu cestu z každého vrcholu do každého vrcholu. Výstupom je matica najnižších cien ciest z $v \in G$ do každého $v \in G$.
		Worst-case: $O(|V|^{3})$

\section{Najlacnejšia kostra grafu}

	\subsection{Algoritmus Union-FindSet} TODO

	\subsection{Kruskalov algoritmus} TODO

\section{Násobenie matíc}

	\subsection{Naivný algoritmus} TODO
	\subsection{Strassenov algoritmus} TODO
	\subsection{Efektívne umocňovanie matice} TODO
	\subsection{Tranzitívny uzáver grafu pomocou umocňovania matíc} TODO


\section{Dynamické programovanie}
	Bottom-up riešenie
	\subsection{Konkrétne príklady použitia} 
		\paragraph{0-1 knapsack} TODO
		\paragraph{Floyd-Warshall} TODO
		\paragraph{Problém násobenia reťazca matíc} TODO

	\subsection{Charakterizácia problémov riešiteľných dynamickým programovaním} TODO
	
	\subsection{Porovnanie iteratívneho prístupu a rekurzie s memoizáciou} TODO


\section{Ďalšie princípy tvorby efektívnych algoritmov}
	\subsection{Rozdeľuj a panuj}
	TODO
	\subsection{Pažravé algoritmy}
		Používajú sa na riešenie optimalizačných problémov. Globálne optimálne riešenie je vytvorené pomocou postupných lokálne optimálnych riešení. Obvykle sú to iteratívne algoritmy, v ktorých problémy redukujeme na podproblémy menšieho rozsahu, v dôsledku čoho sú rýchle.
		\paragraph{Dijkstrov algoritmus}
		\paragraph{Kruskalov algoritmus}
		\paragraph{Racionálny knapsack}
	\subsection{Princíp vyváženosti}
		Stretávame sa s delením väčšieho problému na menšie, prípadne štruktúr na menšie podštruktúry, často vieme zvýšiť efektívnosť algoritmu ich vyváženosťou.
		\paragraph{Príklad:} Ak quicksort vyberá náhodný pivot, v priemernom prípade dosahuje zložitosť $O(n log n)$, pri zlom výbere pivotu to však môže byť až $O(n^{2})$ Chceme teda pivotom deliť na rovnaké - vyvážené časti (vyberieme medián).\\
		\paragraph{Príklad:} BST má v priemere výšku $log n$, vyhľadávanie zložitosť $O(log n)$, ak však vetvy nie sú vyvážené, môže dosiahnuť zložitosť $O(n)$.
	

	\subsection{Voľba vhodnej dátovej štruktúry}
		\paragraph{Abstraktný dátový typ} - abstrakcia nad dátovými štruktúrami popisujúca operácie, ktoré sa budú vykonávať. Podľa najčastejších operácií zvolíme implementáciu s ktorou budú najefektívnejšie.\\

		\begin{table}[h]
			\centering
			\caption{\textbf{Slovník}}
			\label{my-label}
			\begin{tabular}{|l|l|l|l|}
			\hline
			\textbf{Implementácia} & \textbf{Member} & \textbf{Insert} & \textbf{Delete}  \\ \hline
			Pole                   & $O(n)$            & $O(1)$           & $O(n)$             \\ \hline
			Utriedené pole         & $O(log n)$        & $O(n)$            & $O(n)$             \\ \hline
			2-3 stromy             & $O(log n)$        & $O(log n)$        & $O(log n)$          \\ \hline
			Heš                    & $O(1)$/$O(n)$      & $O(1)$/$O(n)$       & $O(1)$/$O(n)$        \\ \hline
			\end{tabular}
		\end{table}

		\begin{table}[h]
			\centering
			\caption{\textbf{Prioritná fronta}}
			\label{my-label}
			\begin{tabular}{|l|l|l|l|}
			\hline
			\textbf{Implementácia} & \textbf{Insert} & \textbf{Min/top} & \textbf{Delete min/pop}   \\ \hline
			Pole                   & $O(1)$            & $O(n)$             & $O(n)$                       \\ \hline
			Utriedené pole         & $O(n)$            & $O(1)$             & $O(1)$                       \\ \hline
			Halda                  & $O(log n)$        & $O(1)$             & $O(log n)$                  \\ \hline
			2-3 stromy             & $O(log n)$        & $O(log n)$         & $O(log n)$                   \\ \hline
			\end{tabular}
		\end{table}